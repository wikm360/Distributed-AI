// rag/rag_manager.dart - RAG Manager for coordinating embedding and ObjectBox
import 'dart:async';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import '../objectbox.g.dart'; // Generated by ObjectBox
import 'rag_entity.dart';
import 'embedding_service.dart';
import 'text_chunker.dart';
import 'pdf_processor.dart';
import '../shared/logger.dart';
import '../shared/models.dart' as models;

class RAGManager {
  Store? _store;
  Box<DocumentChunk>? _chunkBox;
  Box<DocumentFileEmbedding>? _fileBox;
  final EmbeddingService _embeddingService;
  final TextChunker _chunker;
  final PDFProcessor _pdfProcessor;

  bool _isInitialized = false;

  RAGManager(this._embeddingService)
      : _chunker = TextChunker(),
        _pdfProcessor = PDFProcessor();

  bool get isInitialized => _isInitialized;
  bool get isReady => _isInitialized && _embeddingService.isReady;
  EmbeddingService get embeddingService => _embeddingService;
  Store? get store => _store;

  /// Initialize ObjectBox
  Future<bool> initialize() async {
    if (_isInitialized) {
      Log.w('RAGManager already initialized', 'RAGManager');
      return true;
    }

    try {
      final dir = await getApplicationDocumentsDirectory();
      final objectboxDir = Directory('${dir.path}/objectbox');

      Log.i('Initializing ObjectBox at: ${objectboxDir.path}', 'RAGManager');

      _store = await openStore(directory: objectboxDir.path);
      _chunkBox = _store!.box<DocumentChunk>();
      _fileBox = _store!.box<DocumentFileEmbedding>();

      _isInitialized = true;
      Log.s('ObjectBox initialized successfully', 'RAGManager');

      // Log current stats
      final count = _chunkBox!.count();
      Log.i('Current document chunks in DB: $count', 'RAGManager');

      return true;
    } catch (e) {
      Log.e('Failed to initialize ObjectBox', 'RAGManager', e);
      return false;
    }
  }

  /// Load embedding model
  Future<bool> loadEmbeddingModel(models.EmbeddingModel model) async {
    if (!_isInitialized) {
      Log.e('RAGManager not initialized', 'RAGManager');
      return false;
    }

    return await _embeddingService.loadModel(model);
  }

  /// Check and auto-load embedding model if available
  Future<bool> autoLoadEmbeddingModel() async {
    if (!_isInitialized) {
      Log.e('RAGManager not initialized', 'RAGManager');
      return false;
    }

    final installedModel = await _embeddingService.getInstalledModel();
    if (installedModel != null) {
      Log.i('Found installed embedding model: ${installedModel.displayName}',
          'RAGManager');
      return await _embeddingService.loadModel(installedModel);
    }

    Log.i('No embedding model found', 'RAGManager');
    return false;
  }

  /// Import text file and create embeddings
  Future<bool> importTextFile(File file) async {
    if (!isReady) {
      Log.e('RAG system not ready', 'RAGManager');
      return false;
    }

    try {
      Log.i('Importing file: ${file.path}', 'RAGManager');

      final content = await file.readAsString();
      Log.i('File size: ${content.length} characters', 'RAGManager');

      final chunks = _chunker.smartChunk(content);
      Log.i('Created ${chunks.length} chunks', 'RAGManager');

      if (chunks.isEmpty) {
        Log.w('No chunks created from file', 'RAGManager');
        return false;
      }

      final embeddings = await _embeddingService.generateEmbeddings(chunks);

      if (embeddings == null || embeddings.length != chunks.length) {
        Log.e('Failed to generate embeddings', 'RAGManager');
        return false;
      }

      final filename = file.uri.pathSegments.last;
      final documentChunks = <DocumentChunk>[];

      for (int i = 0; i < chunks.length; i++) {
        documentChunks.add(DocumentChunk(
          source: filename,
          content: chunks[i],
          embedding: embeddings[i],
          metadata: 'chunk_${i + 1}_of_${chunks.length}',
        ));
      }

      _chunkBox!.putMany(documentChunks);
      Log.s('Successfully imported ${chunks.length} chunks from $filename',
          'RAGManager');

      await _saveFileEmbedding(
        sourceName: filename,
        fullText: content,
        chunkEmbeddings: embeddings,
        chunkCount: chunks.length,
      );

      return true;
    } catch (e, stack) {
      Log.e('Failed to import file', 'RAGManager', e);
      Log.e('Stack trace:', 'RAGManager', stack);
      return false;
    }
  }

  /// Import PDF file and create embeddings
  Future<bool> importPDFFile(File file) async {
    if (!isReady) {
      Log.e('RAG system not ready', 'RAGManager');
      return false;
    }

    try {
      Log.i('Importing PDF file: ${file.path}', 'RAGManager');

      // Validate PDF first
      final isValid = await _pdfProcessor.validatePDF(file);
      if (!isValid) {
        Log.e('Invalid PDF file', 'RAGManager');
        return false;
      }

      // Extract text from PDF
      final content = await _pdfProcessor.extractTextFromPDF(file);

      if (content == null || content.isEmpty) {
        Log.e('Failed to extract text from PDF or PDF is empty', 'RAGManager');
        return false;
      }

      Log.i('Extracted ${content.length} characters from PDF', 'RAGManager');

      // Chunk the extracted text
      final chunks = _chunker.smartChunk(content);
      Log.i('Created ${chunks.length} chunks from PDF', 'RAGManager');

      if (chunks.isEmpty) {
        Log.w('No chunks created from PDF', 'RAGManager');
        return false;
      }

      // Generate embeddings
      final embeddings = await _embeddingService.generateEmbeddings(chunks);

      if (embeddings == null || embeddings.length != chunks.length) {
        Log.e('Failed to generate embeddings for PDF', 'RAGManager');
        return false;
      }

      final filename = file.uri.pathSegments.last;
      final documentChunks = <DocumentChunk>[];

      for (int i = 0; i < chunks.length; i++) {
        documentChunks.add(DocumentChunk(
          source: filename,
          content: chunks[i],
          embedding: embeddings[i],
          metadata: 'pdf_chunk_${i + 1}_of_${chunks.length}',
        ));
      }

      _chunkBox!.putMany(documentChunks);
      Log.s('Successfully imported ${chunks.length} chunks from PDF: $filename',
          'RAGManager');

      await _saveFileEmbedding(
        sourceName: filename,
        fullText: content,
        chunkEmbeddings: embeddings,
        chunkCount: chunks.length,
      );

      return true;
    } catch (e, stack) {
      Log.e('Failed to import PDF file', 'RAGManager', e);
      Log.e('Stack trace:', 'RAGManager', stack);
      return false;
    }
  }

  /// Import plain text and create embeddings
  Future<bool> importText(String text, String sourceName) async {
    if (!isReady) {
      Log.e('RAG system not ready', 'RAGManager');
      return false;
    }

    try {
      Log.i('Importing text from: $sourceName', 'RAGManager');

      // Chunk text
      final chunks = _chunker.smartChunk(text);
      Log.i('Created ${chunks.length} chunks', 'RAGManager');

      if (chunks.isEmpty) {
        Log.w('No chunks created from text', 'RAGManager');
        return false;
      }

      // Generate embeddings
      final embeddings = await _embeddingService.generateEmbeddings(chunks);

      if (embeddings == null || embeddings.length != chunks.length) {
        Log.e('Failed to generate embeddings', 'RAGManager');
        return false;
      }

      // Save to ObjectBox
      final documentChunks = <DocumentChunk>[];

      for (int i = 0; i < chunks.length; i++) {
        documentChunks.add(DocumentChunk(
          source: sourceName,
          content: chunks[i],
          embedding: embeddings[i],
          metadata: 'chunk_${i + 1}_of_${chunks.length}',
        ));
      }

      _chunkBox!.putMany(documentChunks);
      Log.s('Successfully imported ${chunks.length} chunks from $sourceName',
          'RAGManager');

      await _saveFileEmbedding(
        sourceName: sourceName,
        fullText: text,
        chunkEmbeddings: embeddings,
        chunkCount: chunks.length,
      );

      return true;
    } catch (e) {
      Log.e('Failed to import text', 'RAGManager', e);
      return false;
    }
  }

  /// Search for similar chunks using query
  Future<List<DocumentChunk>> searchSimilar(String query,
      {int maxResults = 2}) async {
    if (!isReady) {
      Log.e('RAG system not ready', 'RAGManager');
      return [];
    }

    try {
      // Debug: Check total chunks in database
      final totalChunks = _chunkBox!.count();
      Log.i('Total chunks in database: $totalChunks', 'RAGManager');

      if (totalChunks == 0) {
        Log.w('No chunks in database', 'RAGManager');
        return [];
      }

      // Debug: Check if embeddings are valid
      final allChunks = _chunkBox!.getAll();
      int validEmbeddings = 0;
      int nullEmbeddings = 0;
      int emptyEmbeddings = 0;

      for (var chunk in allChunks) {
        if (chunk.embedding == null) {
          nullEmbeddings++;
        } else if (chunk.embedding!.isEmpty) {
          emptyEmbeddings++;
        } else {
          validEmbeddings++;
          if (validEmbeddings == 1) {
            Log.i('First chunk embedding dimension: ${chunk.embedding!.length}',
                'RAGManager');
          }
        }
      }

      Log.i(
          'Embeddings: valid=$validEmbeddings, null=$nullEmbeddings, empty=$emptyEmbeddings',
          'RAGManager');

      // Generate embedding for query
      final queryEmbedding = await _embeddingService.generateEmbedding(query);

      if (queryEmbedding == null) {
        Log.e('Failed to generate query embedding', 'RAGManager');
        return [];
      }

      Log.i(
          'Query embedding dimension: ${queryEmbedding.length}', 'RAGManager');
      Log.i(
          'Searching for similar chunks (query: "${query.substring(0, query.length > 50 ? 50 : query.length)}...")',
          'RAGManager');

      // Vector search using ObjectBox HNSW
      // Note: nearestNeighborsF32 expects List<double> and converts internally
      final queryBuilder = _chunkBox!
          .query(
            DocumentChunk_.embedding
                .nearestNeighborsF32(queryEmbedding, maxResults),
          )
          .build();

      final results = queryBuilder.findWithScores();
      queryBuilder.close();

      Log.i('Found ${results.length} similar chunks', 'RAGManager');

      // Log results with scores
      for (int i = 0; i < results.length; i++) {
        final result = results[i];
        Log.i(
            '  Result ${i + 1}: score=${result.score.toStringAsFixed(4)}, source=${result.object.source}',
            'RAGManager');
      }

      return results.map((r) => r.object).toList();
    } catch (e, stack) {
      Log.e('Failed to search similar chunks', 'RAGManager', e);
      Log.e('Stack trace:', 'RAGManager', stack);
      return [];
    }
  }

  Future<List<DocumentFileEmbedding>> searchSimilarFiles(String query,
      {int maxResults = 3}) async {
    if (!isReady) {
      Log.e('RAG system not ready', 'RAGManager');
      return [];
    }
    if (_fileBox == null || _fileBox!.isEmpty()) {
      Log.w('No file embeddings in database', 'RAGManager');
      return [];
    }

    try {
      final queryEmbedding = await _embeddingService.generateEmbedding(query);
      if (queryEmbedding == null) {
        Log.e('Failed to generate query embedding (file search)', 'RAGManager');
        return [];
      }

      final queryBuilder = _fileBox!
          .query(
            DocumentFileEmbedding_.embedding
                .nearestNeighborsF32(queryEmbedding, maxResults),
          )
          .build();

      final results = queryBuilder.findWithScores();
      queryBuilder.close();

      Log.i('Found ${results.length} similar files', 'RAGManager');
      return results.map((r) => r.object).toList();
    } catch (e, stack) {
      Log.e('Failed to search similar files', 'RAGManager', e);
      Log.e('Stack trace:', 'RAGManager', stack);
      return [];
    }
  }

  /// Get all document sources
  List<String> getAllSources() {
    if (!_isInitialized) return [];

    try {
      final chunks = _chunkBox!.getAll();
      final sources = chunks
          .map((c) => c.source ?? '')
          .where((s) => s.isNotEmpty)
          .toSet()
          .toList();
      return sources;
    } catch (e) {
      Log.e('Failed to get sources', 'RAGManager', e);
      return [];
    }
  }

  /// Get chunks by source
  List<DocumentChunk> getChunksBySource(String source) {
    if (!_isInitialized) return [];

    try {
      final query =
          _chunkBox!.query(DocumentChunk_.source.equals(source)).build();
      final results = query.find();
      query.close();
      return results;
    } catch (e) {
      Log.e('Failed to get chunks by source', 'RAGManager', e);
      return [];
    }
  }

  /// Delete chunks by source
  Future<bool> deleteBySource(String source) async {
    if (!_isInitialized) return false;

    try {
      final chunks = getChunksBySource(source);
      final ids = chunks.map((c) => c.id).toList();
      _chunkBox!.removeMany(ids);
      Log.s('Deleted ${ids.length} chunks from source: $source', 'RAGManager');

      final fileQuery =
          _fileBox?.query(DocumentFileEmbedding_.source.equals(source)).build();
      if (fileQuery != null) {
        final fileRecords = fileQuery.find();
        fileQuery.close();
        if (fileRecords.isNotEmpty) {
          _fileBox!.removeMany(fileRecords.map((e) => e.id).toList());
          Log.s(
              'Deleted ${fileRecords.length} file embedding records for $source',
              'RAGManager');
        }
      }
      return true;
    } catch (e) {
      Log.e('Failed to delete chunks', 'RAGManager', e);
      return false;
    }
  }

  /// Get total chunk count
  int getTotalChunkCount() {
    if (!_isInitialized) return 0;
    return _chunkBox!.count();
  }

  /// Clear all chunks
  Future<bool> clearAll() async {
    if (!_isInitialized) return false;

    try {
      _chunkBox!.removeAll();
      _fileBox?.removeAll();
      Log.s('Cleared all document chunks', 'RAGManager');
      return true;
    } catch (e) {
      Log.e('Failed to clear chunks', 'RAGManager', e);
      return false;
    }
  }

  Future<void> _saveFileEmbedding({
    required String sourceName,
    required String fullText,
    required List<List<double>> chunkEmbeddings,
    required int chunkCount,
  }) async {
    if (_fileBox == null) {
      Log.w('File embedding box not initialized', 'RAGManager');
      return;
    }
    List<double>? embedding =
        await _embeddingService.generateEmbedding(fullText);
    embedding ??= _averageEmbedding(chunkEmbeddings);

    if (embedding == null) {
      Log.e('Failed to compute file embedding for $sourceName', 'RAGManager');
      return;
    }

    final record = DocumentFileEmbedding(
      source: sourceName,
      embedding: embedding,
      chunkCount: chunkCount,
      tokenCount: fullText.length,
    );

    _fileBox!.put(
      record,
      mode: PutMode.put,
    );
    Log.s('Stored file-level embedding (averaged from $chunkCount chunks) for $sourceName', 'RAGManager');
  }

  List<double>? _averageEmbedding(List<List<double>> vectors) {
    if (vectors.isEmpty) return null;
    final dimension = vectors.first.length;
    if (dimension == 0) return null;

    final sums = List<double>.filled(dimension, 0.0);
    for (final vector in vectors) {
      if (vector.length != dimension) {
        Log.e(
            'Inconsistent embedding dimensions during averaging', 'RAGManager');
        return null;
      }
      for (int i = 0; i < dimension; i++) {
        sums[i] += vector[i];
      }
    }

    final count = vectors.length.toDouble();
    for (int i = 0; i < dimension; i++) {
      sums[i] /= count;
    }
    return sums;
  }

  /// Dispose resources
  Future<void> dispose() async {
    await _embeddingService.dispose();

    if (_store != null) {
      _store!.close();
      _store = null;
      _chunkBox = null;
      _fileBox = null;
    }

    _isInitialized = false;
    Log.i('RAGManager disposed', 'RAGManager');
  }
}
