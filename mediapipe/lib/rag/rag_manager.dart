// rag/rag_manager.dart - RAG Manager for coordinating embedding and ObjectBox
import 'dart:async';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import '../objectbox.g.dart'; // Generated by ObjectBox
import 'rag_entity.dart';
import 'embedding_service.dart';
import 'text_chunker.dart';
import '../shared/logger.dart';
import '../shared/models.dart' as models;

class RAGManager {
  Store? _store;
  Box<DocumentChunk>? _box;
  final EmbeddingService _embeddingService;
  final TextChunker _chunker;

  bool _isInitialized = false;

  RAGManager(this._embeddingService)
      : _chunker = TextChunker();

  bool get isInitialized => _isInitialized;
  bool get isReady => _isInitialized && _embeddingService.isReady;
  EmbeddingService get embeddingService => _embeddingService;

  /// Initialize ObjectBox
  Future<bool> initialize() async {
    if (_isInitialized) {
      Log.w('RAGManager already initialized', 'RAGManager');
      return true;
    }

    try {
      final dir = await getApplicationDocumentsDirectory();
      final objectboxDir = Directory('${dir.path}/objectbox');

      Log.i('Initializing ObjectBox at: ${objectboxDir.path}', 'RAGManager');

      _store = await openStore(directory: objectboxDir.path);
      _box = _store!.box<DocumentChunk>();

      _isInitialized = true;
      Log.s('ObjectBox initialized successfully', 'RAGManager');

      // Log current stats
      final count = _box!.count();
      Log.i('Current document chunks in DB: $count', 'RAGManager');

      return true;
    } catch (e) {
      Log.e('Failed to initialize ObjectBox', 'RAGManager', e);
      return false;
    }
  }

  /// Load embedding model
  Future<bool> loadEmbeddingModel(models.EmbeddingModel model) async {
    if (!_isInitialized) {
      Log.e('RAGManager not initialized', 'RAGManager');
      return false;
    }

    return await _embeddingService.loadModel(model);
  }

  /// Check and auto-load embedding model if available
  Future<bool> autoLoadEmbeddingModel() async {
    if (!_isInitialized) {
      Log.e('RAGManager not initialized', 'RAGManager');
      return false;
    }

    final installedModel = await _embeddingService.getInstalledModel();
    if (installedModel != null) {
      Log.i('Found installed embedding model: ${installedModel.displayName}', 'RAGManager');
      return await _embeddingService.loadModel(installedModel);
    }

    Log.i('No embedding model found', 'RAGManager');
    return false;
  }

  /// Import text file and create embeddings
Future<bool> importTextFile(File file) async {
  if (!isReady) {
    Log.e('RAG system not ready', 'RAGManager');
    return false;
  }

  try {
    Log.i('Importing file: ${file.path}', 'RAGManager');

    final content = await file.readAsString();
    Log.i('File size: ${content.length} characters', 'RAGManager');

    final chunks = _chunker.smartChunk(content);
    Log.i('Created ${chunks.length} chunks', 'RAGManager');

    if (chunks.isEmpty) {
      Log.w('No chunks created from file', 'RAGManager');
      return false;
    }

    final embeddings = await _embeddingService.generateEmbeddings(chunks);

    if (embeddings == null || embeddings.length != chunks.length) {
      Log.e('Failed to generate embeddings', 'RAGManager');
      return false;
    }

    final filename = file.uri.pathSegments.last;
    final documentChunks = <DocumentChunk>[];

    for (int i = 0; i < chunks.length; i++) {
      documentChunks.add(DocumentChunk(
        source: filename,
        content: chunks[i],
        embedding: embeddings[i],
        metadata: 'chunk_${i + 1}_of_${chunks.length}',
      ));
    }

    _box!.putMany(documentChunks);
    Log.s('Successfully imported ${chunks.length} chunks from $filename', 'RAGManager');

    return true;
  } catch (e, stack) {
    Log.e('Failed to import file', 'RAGManager', e);
    Log.e('Stack trace:', 'RAGManager', stack);
    return false;
  }
}

  /// Import plain text and create embeddings
  Future<bool> importText(String text, String sourceName) async {
    if (!isReady) {
      Log.e('RAG system not ready', 'RAGManager');
      return false;
    }

    try {
      Log.i('Importing text from: $sourceName', 'RAGManager');

      // Chunk text
      final chunks = _chunker.smartChunk(text);
      Log.i('Created ${chunks.length} chunks', 'RAGManager');

      if (chunks.isEmpty) {
        Log.w('No chunks created from text', 'RAGManager');
        return false;
      }

      // Generate embeddings
      final embeddings = await _embeddingService.generateEmbeddings(chunks);

      if (embeddings == null || embeddings.length != chunks.length) {
        Log.e('Failed to generate embeddings', 'RAGManager');
        return false;
      }

      // Save to ObjectBox
      final documentChunks = <DocumentChunk>[];

      for (int i = 0; i < chunks.length; i++) {
        documentChunks.add(DocumentChunk(
          source: sourceName,
          content: chunks[i],
          embedding: embeddings[i],
          metadata: 'chunk_${i + 1}_of_${chunks.length}',
        ));
      }

      _box!.putMany(documentChunks);
      Log.s('Successfully imported ${chunks.length} chunks from $sourceName', 'RAGManager');

      return true;
    } catch (e) {
      Log.e('Failed to import text', 'RAGManager', e);
      return false;
    }
  }

  /// Search for similar chunks using query
  Future<List<DocumentChunk>> searchSimilar(String query, {int maxResults = 2}) async {
    if (!isReady) {
      Log.e('RAG system not ready', 'RAGManager');
      return [];
    }

    try {
      // Debug: Check total chunks in database
      final totalChunks = _box!.count();
      Log.i('Total chunks in database: $totalChunks', 'RAGManager');

      if (totalChunks == 0) {
        Log.w('No chunks in database', 'RAGManager');
        return [];
      }

      // Debug: Check if embeddings are valid
      final allChunks = _box!.getAll();
      int validEmbeddings = 0;
      int nullEmbeddings = 0;
      int emptyEmbeddings = 0;

      for (var chunk in allChunks) {
        if (chunk.embedding == null) {
          nullEmbeddings++;
        } else if (chunk.embedding!.isEmpty) {
          emptyEmbeddings++;
        } else {
          validEmbeddings++;
          if (validEmbeddings == 1) {
            Log.i('First chunk embedding dimension: ${chunk.embedding!.length}', 'RAGManager');
          }
        }
      }

      Log.i('Embeddings: valid=$validEmbeddings, null=$nullEmbeddings, empty=$emptyEmbeddings', 'RAGManager');

      // Generate embedding for query
      final queryEmbedding = await _embeddingService.generateEmbedding(query);

      if (queryEmbedding == null) {
        Log.e('Failed to generate query embedding', 'RAGManager');
        return [];
      }

      Log.i('Query embedding dimension: ${queryEmbedding.length}', 'RAGManager');
      Log.i('Searching for similar chunks (query: "${query.substring(0, query.length > 50 ? 50 : query.length)}...")', 'RAGManager');

      // Vector search using ObjectBox HNSW
      // Note: nearestNeighborsF32 expects List<double> and converts internally
      final queryBuilder = _box!.query(
        DocumentChunk_.embedding.nearestNeighborsF32(queryEmbedding, maxResults),
      ).build();

      final results = queryBuilder.findWithScores();
      queryBuilder.close();

      Log.i('Found ${results.length} similar chunks', 'RAGManager');

      // Log results with scores
      for (int i = 0; i < results.length; i++) {
        final result = results[i];
        Log.i('  Result ${i + 1}: score=${result.score.toStringAsFixed(4)}, source=${result.object.source}', 'RAGManager');
      }

      return results.map((r) => r.object).toList();
    } catch (e, stack) {
      Log.e('Failed to search similar chunks', 'RAGManager', e);
      Log.e('Stack trace:', 'RAGManager', stack);
      return [];
    }
  }

  /// Get all document sources
  List<String> getAllSources() {
    if (!_isInitialized) return [];

    try {
      final chunks = _box!.getAll();
      final sources = chunks.map((c) => c.source ?? '').where((s) => s.isNotEmpty).toSet().toList();
      return sources;
    } catch (e) {
      Log.e('Failed to get sources', 'RAGManager', e);
      return [];
    }
  }

  /// Get chunks by source
  List<DocumentChunk> getChunksBySource(String source) {
    if (!_isInitialized) return [];

    try {
      final query = _box!.query(DocumentChunk_.source.equals(source)).build();
      final results = query.find();
      query.close();
      return results;
    } catch (e) {
      Log.e('Failed to get chunks by source', 'RAGManager', e);
      return [];
    }
  }

  /// Delete chunks by source
  Future<bool> deleteBySource(String source) async {
    if (!_isInitialized) return false;

    try {
      final chunks = getChunksBySource(source);
      final ids = chunks.map((c) => c.id).toList();
      _box!.removeMany(ids);
      Log.s('Deleted ${ids.length} chunks from source: $source', 'RAGManager');
      return true;
    } catch (e) {
      Log.e('Failed to delete chunks', 'RAGManager', e);
      return false;
    }
  }

  /// Get total chunk count
  int getTotalChunkCount() {
    if (!_isInitialized) return 0;
    return _box!.count();
  }

  /// Clear all chunks
  Future<bool> clearAll() async {
    if (!_isInitialized) return false;

    try {
      _box!.removeAll();
      Log.s('Cleared all document chunks', 'RAGManager');
      return true;
    } catch (e) {
      Log.e('Failed to clear chunks', 'RAGManager', e);
      return false;
    }
  }

  /// Dispose resources
  Future<void> dispose() async {
    await _embeddingService.dispose();

    if (_store != null) {
      _store!.close();
      _store = null;
      _box = null;
    }

    _isInitialized = false;
    Log.i('RAGManager disposed', 'RAGManager');
  }
}
